/*
 * SPDX-FileCopyrightText: 2023-2023 Istituto Italiano di Tecnologia (IIT)
 * SPDX-License-Identifier: LGPL-2.1-or-later
 */


// Generated by yarpDeviceParamParserGenerator (1.0)
// This is an automatically generated file. Please do not edit it.
// It will be re-generated if the cmake flag ALLOW_DEVICE_PARAM_PARSER_GERNERATION is ON.

// Generated on: Mon Sep  2 11:30:52 2024


#include "GoogleSpeechSynthesizer_ParamsParser.h"
#include <yarp/os/LogStream.h>
#include <yarp/os/Value.h>

namespace {
    YARP_LOG_COMPONENT(GoogleSpeechSynthesizerParamsCOMPONENT, "yarp.device.GoogleSpeechSynthesizer")
}


GoogleSpeechSynthesizer_ParamsParser::GoogleSpeechSynthesizer_ParamsParser()
{
}


std::vector<std::string> GoogleSpeechSynthesizer_ParamsParser::getListOfParams() const
{
    std::vector<std::string> params;
    params.push_back("language_code");
    params.push_back("voice_name");
    params.push_back("voice_speed");
    params.push_back("voice_pitch");
    return params;
}


bool      GoogleSpeechSynthesizer_ParamsParser::parseParams(const yarp::os::Searchable & config)
{
    //Check for --help option
    if (config.check("help"))
    {
        yCInfo(GoogleSpeechSynthesizerParamsCOMPONENT) << getDocumentationOfDeviceParams();
    }

    std::string config_string = config.toString();
    yarp::os::Property prop_check(config_string.c_str());
    //Parser of parameter language_code
    {
        if (config.check("language_code"))
        {
            m_language_code = config.find("language_code").asString();
            yCInfo(GoogleSpeechSynthesizerParamsCOMPONENT) << "Parameter 'language_code' using value:" << m_language_code;
        }
        else
        {
            yCError(GoogleSpeechSynthesizerParamsCOMPONENT) << "Mandatory parameter 'language_code' not found!";
            yCError(GoogleSpeechSynthesizerParamsCOMPONENT) << "Description of the parameter: Language for speech synthesis (e.g. \"ita\", \"eng\")";
            return false;
        }
        prop_check.unput("language_code");
    }

    //Parser of parameter voice_name
    {
        if (config.check("voice_name"))
        {
            m_voice_name = config.find("voice_name").asString();
            yCInfo(GoogleSpeechSynthesizerParamsCOMPONENT) << "Parameter 'voice_name' using value:" << m_voice_name;
        }
        else
        {
            yCInfo(GoogleSpeechSynthesizerParamsCOMPONENT) << "Parameter 'voice_name' using DEFAULT value:" << m_voice_name;
        }
        prop_check.unput("voice_name");
    }

    //Parser of parameter voice_speed
    {
        if (config.check("voice_speed"))
        {
            m_voice_speed = config.find("voice_speed").asFloat64();
            yCInfo(GoogleSpeechSynthesizerParamsCOMPONENT) << "Parameter 'voice_speed' using value:" << m_voice_speed;
        }
        else
        {
            yCInfo(GoogleSpeechSynthesizerParamsCOMPONENT) << "Parameter 'voice_speed' using DEFAULT value:" << m_voice_speed;
        }
        prop_check.unput("voice_speed");
    }

    //Parser of parameter voice_pitch
    {
        if (config.check("voice_pitch"))
        {
            m_voice_pitch = config.find("voice_pitch").asFloat64();
            yCInfo(GoogleSpeechSynthesizerParamsCOMPONENT) << "Parameter 'voice_pitch' using value:" << m_voice_pitch;
        }
        else
        {
            yCInfo(GoogleSpeechSynthesizerParamsCOMPONENT) << "Parameter 'voice_pitch' using DEFAULT value:" << m_voice_pitch;
        }
        prop_check.unput("voice_pitch");
    }

    /*
    //This code check if the user set some parameter which are not check by the parser
    //If the parser is set in strict mode, this will generate an error
    if (prop_check.size() > 0)
    {
        bool extra_params_found = false;
        for (auto it=prop_check.begin(); it!=prop_check.end(); it++)
        {
            if (m_parser_is_strict)
            {
                yCError(GoogleSpeechSynthesizerParamsCOMPONENT) << "User asking for parameter: "<<it->name <<" which is unknown to this parser!";
                extra_params_found = true;
            }
            else
            {
                yCWarning(GoogleSpeechSynthesizerParamsCOMPONENT) << "User asking for parameter: "<< it->name <<" which is unknown to this parser!";
            }
        }

       if (m_parser_is_strict && extra_params_found)
       {
           return false;
       }
    }
    */
    return true;
}


std::string      GoogleSpeechSynthesizer_ParamsParser::getDocumentationOfDeviceParams() const
{
    std::string doc;
    doc = doc + std::string("\n=============================================\n");
    doc = doc + std::string("This is the help for device: GoogleSpeechSynthesizer\n");
    doc = doc + std::string("\n");
    doc = doc + std::string("This is the list of the parameters accepted by the device:\n");
    doc = doc + std::string("'language_code': Language for speech synthesis (e.g. \"ita\", \"eng\")\n");
    doc = doc + std::string("'voice_name': The voice set for speech synthesis. If not set, the device will pick the first available voice for the selected language code (This page holds the complete list of the available voices: https://cloud.google.com/text-to-speech/docs/voices)\n");
    doc = doc + std::string("'voice_speed': Speaking rate/speed, in the range [0.25, 4.0]. 1.0 is the normal native speed supported by the specific voice. 2.0 is twice as fast, and 0.5 is half as fast.\n");
    doc = doc + std::string("'voice_pitch': Speaking pitch, in the range [-20.0, 20.0]. 20 means increase 20 semitones from the original pitch. -20 means decrease 20 semitones from the original pitch.\n");
    doc = doc + std::string("\n");
    doc = doc + std::string("Here are some examples of invocation command with yarpdev, with all params:\n");
    doc = doc + " yarpdev --device googleSpeechSynthesizer --language_code <mandatory_value> --voice_name <optional_value> --voice_speed 1 --voice_pitch 0\n";
    doc = doc + std::string("Using only mandatory params:\n");
    doc = doc + " yarpdev --device googleSpeechSynthesizer --language_code <mandatory_value>\n";
    doc = doc + std::string("=============================================\n\n");    return doc;
}
