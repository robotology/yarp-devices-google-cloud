/*
 * SPDX-FileCopyrightText: 2023-2023 Istituto Italiano di Tecnologia (IIT)
 * SPDX-License-Identifier: LGPL-2.1-or-later
 */


// Generated by yarpDeviceParamParserGenerator (2.0)
// This is an automatically generated file. Please do not edit it.
// It will be re-generated if the cmake flag ALLOW_DEVICE_PARAM_PARSER_GERNERATION is ON.

// Generated on: Wed Sep 17 14:39:55 2025


#include "GoogleSpeechSynthesizer_ParamsParser.h"
#include <yarp/os/LogStream.h>
#include <yarp/os/Value.h>

namespace {
    YARP_LOG_COMPONENT(GoogleSpeechSynthesizerParamsCOMPONENT, "yarp.device.GoogleSpeechSynthesizer")
}


GoogleSpeechSynthesizer_ParamsParser::GoogleSpeechSynthesizer_ParamsParser()
{
}


std::vector<std::string> GoogleSpeechSynthesizer_ParamsParser::getListOfParams() const
{
    std::vector<std::string> params;
    params.push_back("language_code");
    params.push_back("voice_name");
    params.push_back("voice_speed");
    params.push_back("voice_pitch");
    params.push_back("default_voices");
    return params;
}


bool GoogleSpeechSynthesizer_ParamsParser::getParamValue(const std::string& paramName, std::string& paramValue) const
{
    if (paramName =="language_code")
    {
        paramValue = m_language_code;
        return true;
    }
    if (paramName =="voice_name")
    {
        paramValue = m_voice_name;
        return true;
    }
    if (paramName =="voice_speed")
    {
        paramValue = std::to_string(m_voice_speed);
        return true;
    }
    if (paramName =="voice_pitch")
    {
        paramValue = std::to_string(m_voice_pitch);
        return true;
    }
    if (paramName =="default_voices")
    {
        return false;
    }

    yError() <<"parameter '" << paramName << "' was not found";
    return false;

}


std::string GoogleSpeechSynthesizer_ParamsParser::getConfiguration() const
{
    //This is a sub-optimal solution.
    //Ideally getConfiguration() should return all parameters but it is currently
    //returning only user provided parameters (excluding default values)
    //This behaviour will be fixed in the near future.
    std::string s_cfg = m_provided_configuration;
    return s_cfg;
}

bool      GoogleSpeechSynthesizer_ParamsParser::parseParams(const yarp::os::Searchable & config)
{
    //Check for --help option
    if (config.check("help"))
    {
        yCInfo(GoogleSpeechSynthesizerParamsCOMPONENT) << getDocumentationOfDeviceParams();
    }

    m_provided_configuration = config.toString();
    yarp::os::Property prop_check(m_provided_configuration.c_str());
    //Parser of parameter language_code
    {
        if (config.check("language_code"))
        {
            m_language_code = config.find("language_code").asString();
            yCInfo(GoogleSpeechSynthesizerParamsCOMPONENT) << "Parameter 'language_code' using value:" << m_language_code;
        }
        else
        {
            yCError(GoogleSpeechSynthesizerParamsCOMPONENT) << "Mandatory parameter 'language_code' not found!";
            yCError(GoogleSpeechSynthesizerParamsCOMPONENT) << "Description of the parameter: Language for speech synthesis (e.g. \"it-IT\", \"en-US\")";
            return false;
        }
        prop_check.unput("language_code");
    }

    //Parser of parameter voice_name
    {
        if (config.check("voice_name"))
        {
            m_voice_name = config.find("voice_name").asString();
            yCInfo(GoogleSpeechSynthesizerParamsCOMPONENT) << "Parameter 'voice_name' using value:" << m_voice_name;
        }
        else
        {
            yCInfo(GoogleSpeechSynthesizerParamsCOMPONENT) << "Parameter 'voice_name' using DEFAULT value:" << m_voice_name;
        }
        prop_check.unput("voice_name");
    }

    //Parser of parameter voice_speed
    {
        if (config.check("voice_speed"))
        {
            m_voice_speed = config.find("voice_speed").asFloat64();
            yCInfo(GoogleSpeechSynthesizerParamsCOMPONENT) << "Parameter 'voice_speed' using value:" << m_voice_speed;
        }
        else
        {
            yCInfo(GoogleSpeechSynthesizerParamsCOMPONENT) << "Parameter 'voice_speed' using DEFAULT value:" << m_voice_speed;
        }
        prop_check.unput("voice_speed");
    }

    //Parser of parameter voice_pitch
    {
        if (config.check("voice_pitch"))
        {
            m_voice_pitch = config.find("voice_pitch").asFloat64();
            yCInfo(GoogleSpeechSynthesizerParamsCOMPONENT) << "Parameter 'voice_pitch' using value:" << m_voice_pitch;
        }
        else
        {
            yCInfo(GoogleSpeechSynthesizerParamsCOMPONENT) << "Parameter 'voice_pitch' using DEFAULT value:" << m_voice_pitch;
        }
        prop_check.unput("voice_pitch");
    }

    //Parser of parameter default_voices
    {
        if (config.check("default_voices"))
        {
            {
                m_default_voices.clear();
                yarp::os::Bottle* tempBot = config.find("default_voices").asList();
                if (tempBot)
                {
                    std::string tempBots = tempBot->toString();
                    for (size_t i=0; i<tempBot->size(); i++)
                    {
                        m_default_voices.push_back(tempBot->get(i).asString());
                    }
                }
                else
                {
                     yCError(GoogleSpeechSynthesizerParamsCOMPONENT) <<"parameter 'default_voices' is not a properly formatted bottle";
                }
            }
            yCInfo(GoogleSpeechSynthesizerParamsCOMPONENT) << "Parameter 'default_voices' using value:" << m_default_voices;
        }
        else
        {
            yCInfo(GoogleSpeechSynthesizerParamsCOMPONENT) << "Parameter 'default_voices' using DEFAULT value:" << m_default_voices;
        }
        prop_check.unput("default_voices");
    }

    /*
    //This code check if the user set some parameter which are not check by the parser
    //If the parser is set in strict mode, this will generate an error
    if (prop_check.size() > 0)
    {
        bool extra_params_found = false;
        for (auto it=prop_check.begin(); it!=prop_check.end(); it++)
        {
            if (m_parser_is_strict)
            {
                yCError(GoogleSpeechSynthesizerParamsCOMPONENT) << "User asking for parameter: "<<it->name <<" which is unknown to this parser!";
                extra_params_found = true;
            }
            else
            {
                yCWarning(GoogleSpeechSynthesizerParamsCOMPONENT) << "User asking for parameter: "<< it->name <<" which is unknown to this parser!";
            }
        }

       if (m_parser_is_strict && extra_params_found)
       {
           return false;
       }
    }
    */
    return true;
}


std::string      GoogleSpeechSynthesizer_ParamsParser::getDocumentationOfDeviceParams() const
{
    std::string doc;
    doc = doc + std::string("\n=============================================\n");
    doc = doc + std::string("This is the help for device: GoogleSpeechSynthesizer\n");
    doc = doc + std::string("\n");
    doc = doc + std::string("This is the list of the parameters accepted by the device:\n");
    doc = doc + std::string("'language_code': Language for speech synthesis (e.g. \"it-IT\", \"en-US\")\n");
    doc = doc + std::string("'voice_name': The voice set for speech synthesis. If not set, the device will pick the first available voice for the selected language code (This page holds the complete list of the available voices: https://cloud.google.com/text-to-speech/docs/voices)\n");
    doc = doc + std::string("'voice_speed': Speaking rate/speed, in the range [0.25, 4.0]. 1.0 is the normal native speed supported by the specific voice. 2.0 is twice as fast, and 0.5 is half as fast.\n");
    doc = doc + std::string("'voice_pitch': Speaking pitch, in the range [-20.0, 20.0]. 20 means increase 20 semitones from the original pitch. -20 means decrease 20 semitones from the original pitch.\n");
    doc = doc + std::string("'default_voices': A set of default voices to be automatically set when you change language. (This page holds the complete list of the available voices: https://cloud.google.com/text-to-speech/docs/voices)\n");
    doc = doc + std::string("\n");
    doc = doc + std::string("Here are some examples of invocation command with yarpdev, with all params:\n");
    doc = doc + " yarpdev --device googleSpeechSynthesizer --language_code <mandatory_value> --voice_name <optional_value> --voice_speed 1 --voice_pitch 0 --default_voices <optional_value>\n";
    doc = doc + std::string("Using only mandatory params:\n");
    doc = doc + " yarpdev --device googleSpeechSynthesizer --language_code <mandatory_value>\n";
    doc = doc + std::string("=============================================\n\n");    return doc;
}
